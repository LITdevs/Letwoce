@page
@using System.Security.Claims
@using OpenIddict.Abstractions
@model Lettuce.Pages.GameModel

@{
    ViewData["Title"] = "Lettuce Fighters";
}

<link rel="stylesheet" href="~/css/game.css" asp-append-version="true"/>
<script src="~/js/signalr/dist/browser/signalr.js" asp-append-version="true"></script>

<div id="game">
    <div id="pixi"></div>
    <div id="panels">
        <div id="playerspanel" class="hidden"></div>
        <div id="eventspanel" class="hidden">
            <div class="event">
                <img src="/assets/pawn.png"/>
                <span>Nia exploded at 23/11/2025 19:05:22</span>
                <img src="/assets/pawn.png"/>
            </div>
        </div>
    </div>
</div>


<div id="stats">
    <div class="aviebox">
        <img class="pfp" src="@Model.OwnPawn?.AvatarUri" alt="" referrerpolicy="no-referrer">
        <div class="info">
            <span class="name">@Model.OwnPawn?.DisplayName</span>
            <div class="units">
                <span class="health">
                    <i style="" class="fa-solid fa-heart@(Model.OwnPawn?.Health < 1 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn?.Health < 2 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn?.Health < 3 ? "-crack" : "")"></i>
                </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">@Model.OwnPawn?.Actions</span>
                </span>
            </div>
        </div>
    </div>
    <div class="metas">
        <div class="tabs">
            <button onclick="panelSwap('players')"><img src="/assets/pawn.png"> players</button>
            <button onclick="panelSwap('events')"><img src="/assets/pawn_dead.png"> events</button>
            <button onclick="toggleRange()" ><i class="fa-solid fa-crosshairs" style="color: red"></i> ranges</button>
        </div>
        <span id="pcount">? fighter online</span>
    </div>
</div>

<div style="display:none" id="connection-indicator" class="connection-indicator">
    <i style="display:none" id="connection-indicator-connected" class="fa-regular fa-wifi"></i>
    <i style="display:none" id="connection-indicator-disconnected" class="fa-regular fa-wifi-slash"></i>
    <i style="display:none" id="connection-indicator-connecting" class="fa-regular fa-wifi-slash"></i>
</div>

<script>
    const MY_UUID = "@Model.OwnPawn?.Id.ToString()";
    const GRID_WIDTH = @Program.GridWidth;
    const GRID_HEIGHT = @Program.GridHeight;
    const PAWN_SIZE = 100;
    const TILE_PADDING = 10;
    const TILE_SIZE = PAWN_SIZE+TILE_PADDING;
    const GRID_LINEWIDTH = 2;
    const sleep = ms => new Promise(r => setTimeout(r, ms));
</script>
<script src="/js/pixi/pixi.min.js" asp-append-version="true"></script>
<script src="/js/pixi/pixi_viewport.iife.js" asp-append-version="true"></script>

<script>
    window.lettuce = {};
    window.lettuce.isConnected = false;
    window.lettuce.rangeDisplay = localStorage.getItem("rangeDisplay") === "true";
    window.lettuce.superShitRangeMode = localStorage.getItem("superShitRangeMode") === "true";
    if (localStorage.getItem("rangeDisplay") == null) {
        console.log("Set default range mode");
        window.lettuce.superShitRangeMode = false;
        window.lettuce.rangeDisplay = true;
        localStorage.setItem("superShitRangeMode", "false");
        localStorage.setItem("rangeDisplay", "true");
    }
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("disableUi")) {
        document.getElementById("stats").remove();
        document.getElementById("connection-indicator").remove();
        document.querySelector("header").remove();
        document.getElementById("pixi").style.height = "100vh";
        document.getElementById("game").style.height = "100vh";
    }
    let statusTimeout;
    let connection = new signalR.HubConnectionBuilder()
        .withUrl("/lettuceHub")
        .withAutomaticReconnect()
        .build();

    function toggleRange() {
        // 90% of this function is useless, i added window.lettuce.superShitRangeMode and rangeDisplay before realizing i cant do anything with those
        // but i wont remove it :)
        // hi me 5 minutes later, actually im not sure this would work without the all the the thing the thing the all the stuff 
        if (window.lettuce.superShitRangeMode) { // toggle to disabling everything
            window.lettuce.superShitRangeMode = false;
            window.lettuce.rangeDisplay = false;
            localStorage.setItem("superShitRangeMode", "false");
            localStorage.setItem("rangeDisplay", "false");
            
            if (MY_UUID) window.lettuce.myCircle.visible = false;
            Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
        } else if (window.lettuce.rangeDisplay) { // toggle to super shit range mode
            window.lettuce.superShitRangeMode = true;
            window.lettuce.rangeDisplay = false;
            localStorage.setItem("superShitRangeMode", "true");
            localStorage.setItem("rangeDisplay", "false");

            if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
            Object.entries(window.lettuce.otherCircles).forEach(([id,c]) => c.visible = window.lettuce.pawns.find(p=>p.id===id).alive);
        } else { // toggle to personal range display
            window.lettuce.superShitRangeMode = false;
            window.lettuce.rangeDisplay = true;
            localStorage.setItem("superShitRangeMode", "false");
            localStorage.setItem("rangeDisplay", "true");

            if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
            Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
        }
    }
    function togglePawnRange(pawnId, makeVisible) {
        if(!window.lettuce.pawns.find(p=>p.id===pawnId).alive) return;
        const targetCircle = pawnId === MY_UUID ? window.lettuce.myCircle : window.lettuce.otherCircles[pawnId]; 
        
        if(window.lettuce.superShitRangeMode) {
            if(makeVisible) {
                // focus on the player
                if(MY_UUID) window.lettuce.myCircle.visible = false;
                Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
                targetCircle.visible = true;
            } else {
                // flick everything back on ( GOD end me already )
                if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
                Object.entries(window.lettuce.otherCircles).forEach(([id,c]) => c.visible = window.lettuce.pawns.find(p=>p.id===id).alive);
            }
        } else {
            if(pawnId === MY_UUID && window.lettuce.rangeDisplay) return;
            targetCircle.visible = makeVisible;
        }
    }
    
    showConnectionStatus("connecting")
    connection.start().then(async function () {
        onConnect(false)
        window.lettuce.pawns = await connection.invoke("GetPawns");
        console.log(window.lettuce.pawns);
        
        setInterval(async () => {
            if (!window.lettuce.isConnected) return;
            let count = await connection.invoke("GetLiveCount")
            updateLiveCount(count)
        }, 1000)


        window.lettuce.pawnTexture = await PIXI.Assets.load("/assets/pawn.png");
        window.lettuce.deadPawnTexture = await PIXI.Assets.load("/assets/pawn_dead.png");
        window.lettuce.pawnSprites = {};
        window.lettuce.pawnBoxes = {};
        
        const app = new PIXI.Application();
        window.lettuce.pixiApp = app;
        const pixiBox = document.getElementById("pixi");
        await app.init({background: "rgb(46,46,46)", resizeTo: pixiBox});

        const viewport = new pixi_viewport.Viewport({
            screenWidth: pixiBox.clientWidth, screenHeight: pixiBox.clientHeight,
            worldWidth: TILE_SIZE*GRID_WIDTH, worldHeight: TILE_SIZE*GRID_HEIGHT, events: app.renderer.events
        }); viewport.drag().pinch().wheel().decelerate().clampZoom({minScale:0.2, maxScale:3})
        window.lettuce.viewport = viewport;
        window.lettuce.resizeViewport = () => {
            app.resize(pixiBox.clientWidth, pixiBox.clientHeight);
            viewport.resize(pixiBox.clientWidth, pixiBox.clientHeight);
        }
        window.addEventListener("resize", window.lettuce.resizeViewport)

        const turtle = new PIXI.Graphics();
        const tooltip = new PIXI.DOMContainer();
        window.lettuce.tooltip = tooltip;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.innerHTML = `<div id="tooltip"><div id="tileinfowrap"><div id="tiledata"><span id="tileinfo"><span id="tilecoords"></span>&bull;<span id="hoveredpawn">Nobody</span></span><span id="hoveredunits"></span></div><img class="pfp" src=""></div><span id="actions"></span></div>`
        
        if (urlParams.get("disableUi")) {
            tooltip.element.style.display = "none";
        }
        
        turtle.zIndex = -1;

        drawGrid(turtle);
        viewport.on("zoomed", () => {
            drawGrid(turtle, GRID_LINEWIDTH/viewport.scale.x)
            tooltip.scale = 1/viewport.scale.x;
        })

        let dragging = false;
        viewport.on('mousemove', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            
            if(tooltip.locked) return;
            mkTooltip(tile,pawn,pos);
        });
        viewport.on('pointerup', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            const myPawn = window.lettuce.pawns.find(pawn => pawn.id === MY_UUID);
            
            if(dragging) return;
            
            tooltip.locked = true;
            mkTooltip(tile,pawn,pos);
            tooltip.element.classList.remove("pointerphobe");
            tooltip.element.querySelector("#actions").innerHTML = "";
            
            if(myPawn && pawn !== myPawn) {
                const distance = tileDistance(tile);
                if(!pawn) {
                    if(distance <= 1.5) tooltip.element.querySelector("#actions").appendChild(mkAction("person-walking", "Move here", () => connection.invoke("MoveTo", tile.x, tile.y)))
                } else if(pawn.alive) {
                    if(distance <= 4.25) tooltip.element.querySelector("#actions").appendChild(mkAction("face-angry", "Attack", () => attack(pawn.id)))
                    if(distance <= 7.5) tooltip.element.querySelector("#actions").appendChild(mkAction("hand-holding-heart", "Gift lettuce", () => gift(pawn.id)))
                }
            } else if(myPawn) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("volume", "It's me!", () => {
                    let audio = new Audio("/sfx/itsme.wav");
                    audio.volume = 0.1;
                    audio.play();
                }));
                tooltip.element.querySelector("#actions").appendChild(mkAction("messages", "Chat...", () => connection.invoke("Speak", prompt("What're you gonna say?"))));
            } else if(@(Model.IsPlayer ? "false" : "true")) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("right-to-bracket", "Log in", () => location.pathname = "/login"));
            }
            
            tooltip.element.querySelector("#actions").appendChild(mkAction("ban", "Cancel"));
        });
        viewport.on('drag-start', () => {
            resetTooltip(tooltip);
            dragging = true;
        })
        viewport.on('drag-end', () => setTimeout(() => dragging = false, 0))

        viewport.addChild(tooltip);
        viewport.addChild(turtle);
        app.stage.addChild(viewport);
        document.getElementById("pixi").appendChild(app.canvas);

        window.lettuce.otherCircles = {};
        window.lettuce.pawns.sort((a, b) => a.displayName.localeCompare(b.displayName)).forEach(pawn => {
            const spriteBox = viewport.addChild(new PIXI.Container());
            const sprite = spriteBox.addChild(new PIXI.Sprite(pawn.alive ? window.lettuce.pawnTexture : window.lettuce.deadPawnTexture));

            spriteBox.zIndex = 99;
            sprite.anchor.set(0.5, 0.5);
            sprite.tint = "0x" + pawn.color.name;
            sprite.setSize(PAWN_SIZE);
            sprite.eventMode = "static";
            sprite.pawnID = pawn.id;
            moveToTile(spriteBox, pawn.x, pawn.y, false);
            window.lettuce.pawnSprites[pawn.id] = sprite;
            window.lettuce.pawnBoxes[pawn.id] = spriteBox;
            
            if(pawn.id === "ffffffff-ffff-ffff-ffff-ffffffffffff") return;
            
            const playerBlock = document.createElement("div");
            playerBlock.classList.add("aviebox");
            playerBlock.setAttribute("player", pawn.id)
            playerBlock.onpointerenter = () => togglePawnRange(pawn.id, true);
            playerBlock.onpointerleave = () => togglePawnRange(pawn.id, false);
            playerBlock.innerHTML = `
                <img class="pfp" alt="" referrerpolicy="no-referrer">
                <div class="info">
                    <span class="name"></span>
                    <div class="units">${pawn.alive ? unitStamp(pawn) : deathStamp(pawn)}</div>
                </div>
            `
            playerBlock.querySelector(".pfp").src = pawn.avatarUri;
            playerBlock.querySelector(".name").innerText = pawn.displayName;
            document.querySelector("#playerspanel").appendChild(playerBlock);

            const spriteTurtle = spriteBox.addChild(new PIXI.Graphics());
            spriteTurtle.circle(0, 0, TILE_SIZE*4).stroke({ width: 10, color: 0xff0000 });
            spriteTurtle.circle(0, 0, TILE_SIZE*7).stroke({ width: 10, color: 0x00ff00 });
            if(pawn.id !== MY_UUID && !window.lettuce.superShitRangeMode) spriteTurtle.visible = false;
            if(!window.lettuce.rangeDisplay && !window.lettuce.superShitRangeMode) spriteTurtle.visible = false;
            if(!pawn.alive) spriteTurtle.visible = false;
            if (pawn.id === MY_UUID) {
                window.lettuce.myCircle = spriteTurtle;
            } else {
                window.lettuce.otherCircles[pawn.id] = spriteTurtle;
            }
        })
        window.lettuce.initialLoadDone = true;
        app.ticker.add(() => {})
    }).catch(function (err) {
        return console.error(err.toString());
    });
    
    function showConnectionStatus(status) {
        try {
            if (statusTimeout) clearTimeout(statusTimeout)
            switch (status) {
                case "disconnected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "unset";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "unset";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connecting":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "unset";
                    break;
                default:
                    document.getElementById("connection-indicator").style.display = "none";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
            }
        } catch (e) {
            console.error(e);
        }
    }
    
    connection.onreconnected(() => {
        onConnect(true);
    });

    connection.onclose(() => {
        showConnectionStatus("disconnected");
    })

    connection.onreconnecting(error => {
        onDisconnect(error);
        showConnectionStatus("connecting");
    });

    function onDisconnect(error) {
        console.warn("Connection lost due to error:", error);
        window.lettuce.isConnected = false;
    }

    function onConnect(isReconnect) {
        console.log(`${isReconnect ? "Rec" : "C"}onnected!`);
        window.lettuce.isConnected = true;
        showConnectionStatus("connected");
        statusTimeout = setTimeout(() => {
            showConnectionStatus();
        }, 2000);
    }


    connection.on("UpdateLiveCount", (count) => {
        console.log("Got count from server");
        updateLiveCount(count);
    })
    
    connection.on("MoveTo", (pawnId, x, y, actions) => {
        updatePawn(pawnId, {x,y,actions});
        moveToTile(window.lettuce.pawnBoxes[pawnId], x, y);
    })

    connection.on("Attack", (attackerId, attackedId) => {
        // TODO: Leafy Green this
        console.log(attackerId, attackedId);
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        updatePawn(attackerId, {actions:attacker.actions-1});
        updatePawn(attackedId, {health:attacked.health-1});
        if (attacked.health < 1) {
            updatePawn(attackedId, {
                alive: false,
                killedAt: new Date().getTime(),
                killedById: attackerId
            });
            
            const atkSprite = window.lettuce.pawnSprites[attacked.id];
            if(atkSprite) atkSprite.texture = window.lettuce.deadPawnTexture;
        }
    })

    connection.on("Gift", (attackerId, attackedId, amount) => {
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        updatePawn(attackerId, {actions:attacker.actions-amount})
        updatePawn(attackedId, {actions:attacked.actions+amount})
    })
    
    connection.on("LettuceDrop", (amount) => {
        console.log("Drop", amount);
        window.lettuce.pawns.forEach(pawn => {
            if (pawn.id === "ffffffff-ffff-ffff-ffff-ffffffffffff") return;
            updatePawn(pawn.id, {actions: pawn.actions+amount});
        })
    })
    
    function updateLiveCount(count) {
        document.getElementById("pcount").innerHTML = `${count} fighter${count !== 1 ? "s" : ""} online`;
    }
    
    async function attack(id) {
        await connection.invoke("Attack", id);
    }

    async function gift(id) {
        await connection.invoke("Gift", id);
    }
    
    // Leafy Green

    const posToTile = (pos) => ({x:Math.floor(pos.x/TILE_SIZE),y:Math.floor(pos.y/TILE_SIZE)});
    const tileToPos = (tile) => ({x: tile.x * TILE_SIZE + TILE_SIZE / 2,y: tile.y * TILE_SIZE + TILE_SIZE / 2});
    const isDiffTile = (tile1,tile2) => tile1.x !== tile2.x || tile1.y !== tile2.y;
    const tileDistance = (tile1, tile2=window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        // from lettuce1
        let diffX = tile1.x - tile2.x;
        let diffY = tile1.y - tile2.y;
        return Math.sqrt(diffX * diffX + diffY * diffY);
    }
    const deathStamp = (pawn) => {
        if(!pawn?.killedAt) return "";
        return `<i class="fa-solid fa-tombstone"></i> ${((Date.now() - new Date(pawn.killedAt).getTime()) / 1000 / 60 / 60).toFixed(2)} hours`; //from lettuce1
    }
    const unitStamp = (pawn = window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        if(!pawn) return "";
        return `<span class="health">
                    <i class="fa-solid fa-heart${pawn.health<1?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<2?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<3?"-crack":""}"></i>
                 </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">${pawn.actions}</span>
                </span>`
    }
    
    const moveToTile = async (sprite, tx, ty, animate = true) => {
        const sx = tx * TILE_SIZE + TILE_SIZE / 2; const sy = ty * TILE_SIZE + TILE_SIZE / 2;
        return animate ? move(sprite, tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2) : sprite.position.set(sx,sy);
    }
    async function move(sprite, x, y) {
        if(sprite.animControl) {
            sprite.animControl.abort();
            sprite.animControl = null;
        }

        sprite.animControl = new AbortController();
        const {signal} = sprite.animControl;
        const xDiff = (x-sprite.position.x)/3;
        const yDiff = (y-sprite.position.y)/3;
        const bump = async () => {await sleep(225);if(signal.aborted)throw"stop";sprite.position.set(sprite.position.x+xDiff, sprite.position.y+yDiff);}

        try {
            await bump();
            sprite.angle = 15;
            await bump();
            sprite.angle = -15;
            await bump();
            sprite.position.set(x, y);
        } catch {} finally {
            sprite.angle = 0;
            if(sprite.animControl?.signal === signal) sprite.animControl = null;
        }
    }
    function drawGrid(turtle, width = GRID_LINEWIDTH) {
        turtle.clear();
        for (let i = 0; i < GRID_HEIGHT; i++) {
            turtle.moveTo(0,TILE_SIZE*i).lineTo(TILE_SIZE*GRID_WIDTH, TILE_SIZE*i).stroke({width: width});
        }
        for (let i = 0; i < GRID_WIDTH; i++) {
            turtle.moveTo(TILE_SIZE*i,0).lineTo(TILE_SIZE*i, TILE_SIZE*GRID_HEIGHT).stroke({width: width});
        }
        turtle.rect(0,0,TILE_SIZE*GRID_WIDTH,TILE_SIZE*GRID_HEIGHT).stroke({width: width})
        
        let arrowFrom = urlParams.get('arrowFrom');
        let arrowTo = urlParams.get('arrowTo');
        if (arrowFrom && arrowTo) {
            turtle.zIndex = 100;
            let arrowThickness = 7;
            let fromX = Number(arrowFrom.split(",")[0])
            let fromY = Number(arrowFrom.split(",")[1])
            let toX = Number(arrowTo.split(",")[0])
            let toY = Number(arrowTo.split(",")[1])
            let fromPos = tileToPos({x: fromX, y: fromY})
            let toPos = tileToPos({x: toX, y: toY});
            turtle.moveTo(fromPos.x, fromPos.y)
                .lineTo(toPos.x, toPos.y)
                .stroke({ color: 0xff0000, width: arrowThickness })
            const arrowSize = 45; // length of arrow head lines
            const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);

            // Two points for arrow head
            const leftAngle = angle + Math.PI / 6; // 30Â° spread
            const rightAngle = angle - Math.PI / 6;

            const leftX = toPos.x - Math.cos(leftAngle) * arrowSize;
            const leftY = toPos.y - Math.sin(leftAngle) * arrowSize;

            const rightX = toPos.x - Math.cos(rightAngle) * arrowSize;
            const rightY = toPos.y - Math.sin(rightAngle) * arrowSize;

            turtle.moveTo(toPos.x, toPos.y)
                .lineTo(leftX, leftY)
                .moveTo(toPos.x, toPos.y)
                .lineTo(rightX, rightY)
                .stroke({ color: 0xff0000, width: arrowThickness })
            
            window.lettuce.viewport.moveCenter((fromPos.x + toPos.x) / 2, (fromPos.y + toPos.y) / 2);
            window.lettuce.viewport.setZoom(0.5, true);
            //turtle.zIndex = -1;
        }
    }
    
    function resetTooltip(tooltip = window.lettuce.tooltip) {
        tooltip.locked = false;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.querySelector("#actions").innerHTML = "";
    }
    function mkTooltip(tile, pawn, pos, tooltip = window.lettuce.tooltip) {
        tooltip.element.querySelector("#tilecoords").innerText = `(${tile.x},${tile.y})`;
        tooltip.element.querySelector("#hoveredpawn").innerText = pawn ? pawn.displayName : "Nobody";
        tooltip.element.querySelector(".pfp").src = pawn?.avatarUri ? pawn.avatarUri : "";
        if(pawn?.killedAt) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = deathStamp(pawn);
        } else if(pawn) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = unitStamp(pawn);
        } else {
            tooltip.element.querySelector("#hoveredunits").innerHTML = "";
        }
        tooltip.position.set(pos.x+20,pos.y);
    }
    function mkAction(icon, text, onclick = () => {}) {
        const action = document.createElement("button");
        action.innerHTML = `<i class="fa-solid fa-${icon}"></i> ${text}`;
        action.onclick = () => {
            onclick();
            resetTooltip();
        };
        return action;
    }
    function updatePawn(id, data) {
        const pawn = window.lettuce.pawns.find(pawn=>pawn.id===id);
        if(!pawn) return;
        
        Object.assign(pawn, data);
        document.querySelector(`#playerspanel [player="${id}"]`).querySelector(".units").innerHTML = pawn.alive ? unitStamp(pawn) : deathStamp(pawn);
        if(id === MY_UUID) document.querySelector(`#stats .units`).innerHTML = pawn.alive ? unitStamp(pawn) : deathStamp(pawn);
        
        // TODO: change pawn sprite too
    }
    
    // "im doing [something] in such a sketchy way", emilia tells me, while i'm writing my own sketchy code. sketchiness forever!!
    function panelSwap(panel) {
        const wantedPanel = document.querySelector(`#panels #${panel}panel`);
        if(!wantedPanel.classList.contains('hidden')) {
            wantedPanel.classList.add("hidden");
            game.removeAttribute("active-panel");
        } else {
            const currentPanel = document.querySelector(`#panels #${game.getAttribute("active-panel")}panel`);
            if(currentPanel) currentPanel.classList.add("hidden");
            wantedPanel.classList.remove("hidden");
            
            game.setAttribute("active-panel", panel)
        }
        window.lettuce.resizeViewport();
    }
    
</script>
