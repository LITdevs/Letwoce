@page
@using System.Security.Claims
@using OpenIddict.Abstractions
@model Lettuce.Pages.GameModel

@{
    ViewData["Title"] = "Lettuce Fighters";
}

<link rel="stylesheet" href="~/css/game.css" asp-append-version="true"/>
<script src="~/js/signalr/dist/browser/signalr.js" asp-append-version="true"></script>

<div id="game">
    <div id="pixi"></div>
    <div id="panels">
        <div id="playerspanel" class="hidden"></div>
        <div id="eventspanel" class="hidden"></div>
    </div>
</div>


<div id="stats">
    <div class="aviebox">
        <img class="pfp" src="@(@Model.OwnPawn?.AvatarUri ?? "/assets/pawn.png")" alt="" referrerpolicy="no-referrer">
        <div class="info">
            <span class="name">@(@Model.OwnPawn?.DisplayName ?? "Guest")</span>
            <div class="units">
                <span class="health">
                    <i style="" class="fa-solid fa-heart@(Model.OwnPawn == null || Model.OwnPawn?.Health < 1 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn == null || Model.OwnPawn?.Health < 2 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn == null || Model.OwnPawn?.Health < 3 ? "-crack" : "")"></i>
                </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">@(@Model.OwnPawn?.Actions.ToString() ?? "N/A")</span>
                </span>
            </div>
        </div>
    </div>
    <div class="metas">
        <div class="tabs">
            <button onclick="panelSwap('players')"><img src="/assets/pawn.png"> players</button>
            <button onclick="panelSwap('events')"><img src="/assets/pawn_dead.png"> events</button>
            <button onclick="toggleRange()" ><i class="fa-solid fa-crosshairs" style="color: red"></i> ranges</button>
        </div>
        <span id="pcount">? fighter online</span>
    </div>
</div>

<div style="display:none" id="connection-indicator" class="connection-indicator">
    <i style="display:none" id="connection-indicator-connected" class="fa-regular fa-wifi"></i>
    <i style="display:none" id="connection-indicator-disconnected" class="fa-regular fa-wifi-slash"></i>
    <i style="display:none" id="connection-indicator-connecting" class="fa-regular fa-wifi-slash"></i>
</div>

<script>
    const MY_UUID = "@Model.OwnPawn?.Id.ToString()";
    const FIRST_EVENT_TIME = new Date(@Model.FirstEventTime.ToUnixTimeMilliseconds());
    const SCOL_VOTE = "@Model.OwnPawn?.Vote";
    const GRID_WIDTH = @Program.GridWidth;
    const GRID_HEIGHT = @Program.GridHeight;
    const PAWN_SIZE = 100;
    const TILE_PADDING = 10;
    const TILE_SIZE = PAWN_SIZE+TILE_PADDING;
    const GRID_LINEWIDTH = 2;
    const RANGE_LINEWIDTH = 10;
    const sleep = ms => new Promise(r => setTimeout(r, ms));
</script>
<script src="/js/tint.js" asp-append-version="true"></script>
<script src="/js/pixi/pixi.min.js" asp-append-version="true"></script>
<script src="/js/pixi/pixi_viewport.iife.js" asp-append-version="true"></script>

<script>
    window.lettuce = {};
    window.lettuce.isConnected = false;
    window.lettuce.rangeDisplay = localStorage.getItem("rangeDisplay") === "true";
    window.lettuce.superShitRangeMode = localStorage.getItem("superShitRangeMode") === "true";
    const anyRangeMode = () => window.lettuce.rangeDisplay || window.lettuce.superShitRangeMode;
    if (localStorage.getItem("rangeDisplay") == null) {
        console.log("Set default range mode");
        window.lettuce.superShitRangeMode = false;
        window.lettuce.rangeDisplay = true;
        localStorage.setItem("superShitRangeMode", "false");
        localStorage.setItem("rangeDisplay", "true");
    }
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("disableUi")) {
        document.getElementById("stats").remove();
        document.getElementById("connection-indicator").remove();
        document.querySelector("header").remove();
        document.getElementById("pixi").style.height = "100vh";
        document.getElementById("game").style.height = "100vh";
    }
    let statusTimeout;
    let connection = new signalR.HubConnectionBuilder()
        .withUrl("/lettuceHub")
        .withAutomaticReconnect()
        .build();

    function toggleRange() {
        // 90% of this function is useless, i added window.lettuce.superShitRangeMode and rangeDisplay before realizing i cant do anything with those
        // but i wont remove it :)
        // hi me 5 minutes later, actually im not sure this would work without the all the the thing the thing the all the stuff 
        if (window.lettuce.superShitRangeMode) { // toggle to disabling everything
            window.lettuce.superShitRangeMode = false;
            window.lettuce.rangeDisplay = false;
            localStorage.setItem("superShitRangeMode", "false");
            localStorage.setItem("rangeDisplay", "false");
            
            if (MY_UUID) window.lettuce.myCircle.visible = false;
            Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
        } else if (window.lettuce.rangeDisplay) { // toggle to super shit range mode
            window.lettuce.superShitRangeMode = true;
            window.lettuce.rangeDisplay = false;
            localStorage.setItem("superShitRangeMode", "true");
            localStorage.setItem("rangeDisplay", "false");

            if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
            Object.entries(window.lettuce.otherCircles).forEach(([id,c]) => c.visible = window.lettuce.pawns.find(p=>p.id===id).alive);
        } else { // toggle to personal range display
            window.lettuce.superShitRangeMode = false;
            window.lettuce.rangeDisplay = true;
            localStorage.setItem("superShitRangeMode", "false");
            localStorage.setItem("rangeDisplay", "true");

            if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
            Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
        }
    }
    function togglePawnRange(pawnId, makeVisible) {
        const targetCircle = pawnId === MY_UUID ? window.lettuce.myCircle : window.lettuce.otherCircles[pawnId];
        const pos = window.lettuce.pawnBoxes[pawnId].position;
        if(makeVisible) mkTooltip(posToTile(pos), window.lettuce.pawns.find(p=>p.id===pawnId), pos);
        
        if(!window.lettuce.pawns.find(p=>p.id===pawnId).alive) return;
        if(window.lettuce.superShitRangeMode) {
            if(makeVisible) {
                // focus on the player
                if(MY_UUID) window.lettuce.myCircle.visible = false;
                Object.values(window.lettuce.otherCircles).forEach(c => c.visible = false);
                targetCircle.visible = true;
            } else {
                // flick everything back on ( GOD end me already )
                if (MY_UUID && window.lettuce.pawns.find(p=>p.id===MY_UUID).alive) window.lettuce.myCircle.visible = true;
                Object.entries(window.lettuce.otherCircles).forEach(([id,c]) => c.visible = window.lettuce.pawns.find(p=>p.id===id).alive);
            }
        } else {
            if(pawnId === MY_UUID && window.lettuce.rangeDisplay) return;
            targetCircle.visible = makeVisible;
        }
    }
    function toggleTempRange(tile) {
        const existingRange = window.lettuce.temporaryCircles[[tile.x,tile.y]];
        if(existingRange) {
            window.lettuce.viewport.removeChild(existingRange);
            existingRange.destroy();
            delete window.lettuce.temporaryCircles[[tile.x,tile.y]];
        } else {
            const newRange = window.lettuce.viewport.addChild(new PIXI.Graphics());
            window.lettuce.temporaryCircles[[tile.x,tile.y]] = newRange;
            
            newRange.position = tileToPos(tile); mkCircle(newRange);
        }
    }
    
    showConnectionStatus("connecting")
    connection.start().then(async function () {
        onConnect(false);
        
        window.lettuce.pawns = await connection.invoke("GetPawns");
        console.log(window.lettuce.pawns);
        
        setInterval(async () => {
            if (!window.lettuce.isConnected) return;
            let count = await connection.invoke("GetLiveCount")
            updateLiveCount(count)
        }, 1000)

        window.lettuce.pawnTexture = await PIXI.Assets.load("/assets/pawn_gs.png");
        window.lettuce.pawnTextureA = await PIXI.Assets.load("/assets/pawn_a.png");
        window.lettuce.pawnTextureWinner = await PIXI.Assets.load("/assets/pawn_winner.png");
        window.lettuce.deadPawnTexture = await PIXI.Assets.load("/assets/pawn_dead_gs.png");
        window.lettuce.deadPawnTextureA = await PIXI.Assets.load("/assets/pawn_dead_a.png");
        window.lettuce.pawnSpriteTints = {};
        window.lettuce.pawnSprites = {};
        window.lettuce.pawnBoxes = {};
        
        const app = new PIXI.Application();
        window.lettuce.pixiApp = app;
        const pixiBox = document.getElementById("pixi");
        await app.init({background: "rgb(46,46,46)", resizeTo: pixiBox});

        const viewport = new pixi_viewport.Viewport({
            screenWidth: pixiBox.clientWidth, screenHeight: pixiBox.clientHeight,
            worldWidth: TILE_SIZE*GRID_WIDTH, worldHeight: TILE_SIZE*GRID_HEIGHT, events: app.renderer.events
        }); viewport.drag().pinch().wheel().decelerate().clampZoom({minScale:0.2, maxScale:3})
        window.lettuce.viewport = viewport;
        window.lettuce.resizeViewport = () => {
            app.resize(pixiBox.clientWidth, pixiBox.clientHeight);
            viewport.resize(pixiBox.clientWidth, pixiBox.clientHeight);
        }
        window.addEventListener("resize", window.lettuce.resizeViewport);

        const gameEvents = await connection.invoke("GetEvents");
        gameEvents.reverse().forEach(mkEvent);
        if(gameEvents.length === 50) eventspanel.innerHTML += "<span>Can't load more than that, sorry! :3<br/><br/></span>";
        if(gameEvents.length === 0) eventspanel.innerHTML += "<span>No events yet, try doing something!<br/><br/></span>";
        if(!matchMedia("(max-width: 60em)").matches) panelSwap("events");
        

        const turtle = new PIXI.Graphics();
        const tooltip = new PIXI.DOMContainer();
        window.lettuce.tooltip = tooltip;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.innerHTML = `<div id="tooltip"><div id="tileinfowrap"><div id="tiledata"><span id="tileinfo"><span id="tilecoords"></span>&bull;<span id="hoveredpawn">Nobody</span></span><span id="hoveredunits"></span><span id="killer"></span></div><img class="pfp" src=""></div><span id="actions"></span></div>`
        
        if (urlParams.get("disableUi")) {
            tooltip.element.style.display = "none";
        }
        
        turtle.zIndex = -1;

        drawGrid(turtle);
        viewport.on("zoomed", () => {
            drawGrid(turtle, GRID_LINEWIDTH/viewport.scale.x)
            tooltip.scale = 1/viewport.scale.x;
        })
        viewport.setZoom(0.3);
        viewport.moveCenter(TILE_SIZE*GRID_WIDTH/2,TILE_SIZE*GRID_HEIGHT/2);
        viewport.emit("zoomed");

        let dragging = false;
        viewport.on('mousemove', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            
            if(tooltip.locked) return;
            mkTooltip(tile,pawn,pos);
        });
        viewport.on('pointerup', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            const myPawn = window.lettuce.pawns.find(pawn => pawn.id === MY_UUID);
            
            if(dragging) return;
            if(tile.x < 0 || tile.x >= GRID_WIDTH) return;
            if(tile.y < 0 || tile.y >= GRID_HEIGHT) return;

            tooltip.locked = true;
            mkTooltip(tile,pawn,pos);
            tooltip.element.classList.remove("pointerphobe");
            tooltip.element.querySelector("#actions").innerHTML = "";
            
            if(myPawn && pawn !== myPawn) {
                const distance = tileDistance(tile);
                if(!myPawn.alive && pawn?.alive) {
                    tooltip.element.querySelector("#actions").appendChild(mkAction("hand-holding-heart", `Vote${pawn.voted?"d":""}`, async () => {
                        const prevVote = window.lettuce.pawns.find(p=>p.voted===true);
                        await connection.invoke("Vote", pawn.id) // https://youtu.be/J9udiROQchg?t=430
                        
                        if(prevVote) updatePawn(prevVote.id, {voted: false});
                        updatePawn(pawn.id, {voted: true});
                    }))
                } else if(!pawn) {
                    if(distance <= 1.5) tooltip.element.querySelector("#actions").appendChild(mkAction("person-walking", "Move here", () => connection.invoke("MoveTo", tile.x, tile.y)))
                } else if(pawn.alive) {
                    if(distance <= 4.25) tooltip.element.querySelector("#actions").appendChild(mkAction("face-angry", "Attack", () => connection.invoke("Attack", pawn.id)))
                    if(distance <= 7.5) tooltip.element.querySelector("#actions").appendChild(mkAction("hand-holding-heart", "Gift lettuce", () => connection.invoke("Gift", pawn.id)))
                }
            } else if(myPawn?.alive) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("volume", "It's me!", () => {
                    let audio = new Audio("/sfx/itsme.wav");
                    audio.volume = 0.1;
                    audio.play();
                }));
                tooltip.element.querySelector("#actions").appendChild(mkAction("messages", "Chat...", () => connection.invoke("Speak", prompt("What're you gonna say?"))));
            } else if(@(Model.IsPlayer ? "false" : "true")) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("right-to-bracket", "Log in", () => location.pathname = "/login"));
            }

            if(!pawn?.alive || !window.lettuce.superShitRangeMode) tooltip.element.querySelector("#actions").appendChild(mkAction("crosshairs", "Range", () => toggleTempRange(tile)));
            tooltip.element.querySelector("#actions").appendChild(mkAction("ban", "Cancel"));
        });
        viewport.on('drag-start', () => {
            resetTooltip(tooltip);
            dragging = true;
        })
        viewport.on('drag-end', () => setTimeout(() => dragging = false, 0))

        viewport.addChild(tooltip);
        viewport.addChild(turtle);
        app.stage.addChild(viewport);
        document.getElementById("pixi").appendChild(app.canvas);

        window.lettuce.otherCircles = {};
        window.lettuce.temporaryCircles = {};
        let pawnsAlive = window.lettuce.pawns.filter(p => p.alive).length
        window.lettuce.pawns.sort((a, b) => a.displayName.localeCompare(b.displayName)).forEach(pawn => {
            const spriteBox = viewport.addChild(new PIXI.Container());
            const sprite = spriteBox.addChild(new PIXI.Sprite(pawn.alive ? window.lettuce.pawnTexture : window.lettuce.deadPawnTexture));
            const spriteTint = spriteBox.addChild(new PIXI.Sprite(pawn.alive ? window.lettuce.pawnTextureA : window.lettuce.deadPawnTextureA));
            
            spriteBox.zIndex = 99;
            spriteTint.blendMode = 'multiply';
            spriteTint.tint = { r: pawn.color.r, g: pawn.color.g, b: pawn.color.b, a: pawn.color.a };
            sprite.anchor.set(0.5, 0.5);
            spriteTint.anchor.set(0.5, 0.5);
            
            sprite.setSize(PAWN_SIZE);
            spriteTint.setSize(PAWN_SIZE);
            moveToTile(spriteBox, pawn.x, pawn.y, false);
            window.lettuce.pawnSpriteTints[pawn.id] = spriteTint;
            window.lettuce.pawnSprites[pawn.id] = sprite;
            window.lettuce.pawnBoxes[pawn.id] = spriteBox;
            
            if(pawn.id === "ffffffff-ffff-ffff-ffff-ffffffffffff") return;
            if(SCOL_VOTE) pawn.voted = pawn.id === SCOL_VOTE;

            if (pawnsAlive === 2 && pawn.alive) {
                spriteTint.tint = 0xffffff
                sprite.texture = window.lettuce.pawnTextureWinner
            }
            
            const playerBlock = document.createElement("div");
            playerBlock.classList.add("aviebox");
            playerBlock.setAttribute("player", pawn.id)
            playerBlock.onmouseenter = () => togglePawnRange(pawn.id, true);
            playerBlock.onmouseleave = () => togglePawnRange(pawn.id, false);
            playerBlock.onclick = () => jumpToPawn(pawn.id);
            playerBlock.innerHTML = `
                <div class="pfp stuffed">
                    <img alt="" referrerpolicy="no-referrer" class="itsme">
                    <img src="/assets/lettuce.png" alt="Voted" class="voteicon hidden">
                </div>
                <div class="info">
                    <span class="name"></span>
                    <div class="units">${pawn.alive ? unitStamp(pawn) : deathStamp(pawn)}</div>
                </div>
            `
            playerBlock.querySelector(".pfp img").src = pawn.avatarUri ?? "/assets/p3b.png";
            playerBlock.querySelector(".pfp .voteicon").classList.toggle("hidden", !pawn.voted);
            playerBlock.querySelector(".name").innerText = pawn.displayName;
            document.querySelector("#playerspanel").appendChild(playerBlock);

            const spriteTurtle = spriteBox.addChild(new PIXI.Graphics());
            mkCircle(spriteTurtle);
            if(pawn.id !== MY_UUID && !window.lettuce.superShitRangeMode) spriteTurtle.visible = false;
            if(!window.lettuce.rangeDisplay && !window.lettuce.superShitRangeMode) spriteTurtle.visible = false;
            if(!pawn.alive) spriteTurtle.visible = false;
            if (pawn.id === MY_UUID) {
                window.lettuce.myCircle = spriteTurtle;
            } else {
                window.lettuce.otherCircles[pawn.id] = spriteTurtle;
            }
        })
        window.lettuce.initialLoadDone = true;
        app.ticker.add(() => {})
    }).catch(function (err) {
        return console.error(err.toString());
    });
    
    function showConnectionStatus(status) {
        try {
            if (statusTimeout) clearTimeout(statusTimeout)
            switch (status) {
                case "disconnected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "unset";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "unset";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connecting":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "unset";
                    break;
                default:
                    document.getElementById("connection-indicator").style.display = "none";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
            }
        } catch (e) {
            console.error(e);
        }
    }
    
    connection.onreconnected(() => {
        onConnect(true);
    });

    connection.onclose(() => {
        showConnectionStatus("disconnected");
    })

    connection.onreconnecting(error => {
        onDisconnect(error);
        showConnectionStatus("connecting");
    });

    function onDisconnect(error) {
        console.warn("Connection lost due to error:", error);
        window.lettuce.isConnected = false;
    }

    function onConnect(isReconnect) {
        console.log(`${isReconnect ? "Rec" : "C"}onnected!`);
        window.lettuce.isConnected = true;
        showConnectionStatus("connected");
        statusTimeout = setTimeout(() => {
            showConnectionStatus();
        }, 2000);
    }

    connection.on("NewEvent", (eventDto) => {
        mkEvent(eventDto)
        if (eventDto.actionType === 6) {
            console.log("Winner winner", eventDto)
            window.lettuce.pawnSprites[eventDto.actionById].texture = window.lettuce.pawnTextureWinner;
            window.lettuce.pawnSpriteTints[eventDto.actionById].tint = 0xffffff;
            // insert confetti here - wow you remembered <3
        }
    })

    connection.on("UpdateLiveCount", (count) => {
        console.log("Got count from server");
        updateLiveCount(count);
    })
    
    connection.on("MoveTo", (pawnId, x, y, actions) => {
        updatePawn(pawnId, {x,y,actions});
        moveToTile(window.lettuce.pawnBoxes[pawnId], x, y);
    })

    connection.on("Attack", (attackerId, attackedId) => {
        // TODO: Leafy Green this
        console.log(attackerId, attackedId);
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        updatePawn(attackerId, {actions:attacker.actions-1});
        updatePawn(attackedId, {health:attacked.health-1});
        if (attacked.health < 1) {
            updatePawn(attackedId, {
                alive: false,
                killedAt: new Date().getTime(),
                killedById: attackerId,
                voted: false
            });

            const atkSprite = window.lettuce.pawnSprites[attacked.id];
            const atkSpriteTint = window.lettuce.pawnSpriteTints[attacked.id];
            if(atkSprite) {
                atkSprite.texture = window.lettuce.deadPawnTexture;
                atkSpriteTint.texture = window.lettuce.deadPawnTextureA;
            }

            const range = attackedId === MY_UUID ? window.lettuce.myCircle : window.lettuce.otherCircles[attackedId];
            if(range) range.visible = false;
        }
    })

    connection.on("Gift", (attackerId, attackedId, amount) => {
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        updatePawn(attackerId, {actions:attacker.actions-amount})
        updatePawn(attackedId, {actions:attacked.actions+amount})
    })
    
    connection.on("LettuceDrop", (amount) => {
        window.lettuce.pawns.forEach(pawn => {
            if (pawn.id === "ffffffff-ffff-ffff-ffff-ffffffffffff") return;
            updatePawn(pawn.id, {actions: pawn.actions+amount});
        })
    })
    
    function updateLiveCount(count) {
        document.getElementById("pcount").innerHTML = `${count} fighter${count !== 1 ? "s" : ""} online`;
    }
    
    // Leafy Green

    const posToTile = (pos) => ({x:Math.floor(pos.x/TILE_SIZE),y:Math.floor(pos.y/TILE_SIZE)});
    const tileToPos = (tile) => ({x: tile.x * TILE_SIZE + TILE_SIZE / 2,y: tile.y * TILE_SIZE + TILE_SIZE / 2});
    const isDiffTile = (tile1,tile2) => tile1.x !== tile2.x || tile1.y !== tile2.y;
    const tileDistance = (tile1, tile2=window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        // from lettuce1
        let diffX = tile1.x - tile2.x;
        let diffY = tile1.y - tile2.y;
        return Math.sqrt(diffX * diffX + diffY * diffY);
    }

    const dayDiff = (d1, d2) => {
        const date1 = new Date(d1), date2 = new Date(d2);
        date1.setHours(0, 0, 0, 0); date2.setHours(0, 0, 0, 0);
        return (date2 - date1) / (1000 * 60 * 60 * 24);
    };
    
    const deathStamp = (pawn) => {
        if(!pawn?.killedAt) return "";
        return `<i class="fa-solid fa-tombstone"></i> ${((Date.now() - new Date(pawn.killedAt).getTime()) / 1000 / 60 / 60).toFixed(2)} hours`; //from lettuce1
    }
    const unitStamp = (pawn = window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        if(!pawn) return "";
        return `<span class="health">
                    <i class="fa-solid fa-heart${pawn.health<1?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<2?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<3?"-crack":""}"></i>
                 </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">${pawn.actions}</span>
                </span>`
    }

    const jumpToPawn = (pawnId) => {
        if(matchMedia("(max-width: 60em)").matches) panelSwap("players");
        
        const pos = window.lettuce.pawnBoxes[pawnId].position
        window.lettuce.viewport.moveCenter(pos);
        mkTooltip(posToTile(pos), window.lettuce.pawns.find(p=>p.id===pawnId), pos);
    }
    const moveToTile = async (sprite, tx, ty, animate = true) => {
        const sx = tx * TILE_SIZE + TILE_SIZE / 2; const sy = ty * TILE_SIZE + TILE_SIZE / 2;
        return animate ? move(sprite, tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2) : sprite.position.set(sx,sy);
    }
    async function move(sprite, x, y) {
        if(sprite.animControl) {
            sprite.animControl.abort();
            sprite.animControl = null;
        }

        sprite.animControl = new AbortController();
        const {signal} = sprite.animControl;
        const xDiff = (x-sprite.position.x)/3;
        const yDiff = (y-sprite.position.y)/3;
        const bump = async () => {await sleep(225);if(signal.aborted)throw"stop";sprite.position.set(sprite.position.x+xDiff, sprite.position.y+yDiff);}

        try {
            await bump();
            sprite.angle = 15;
            await bump();
            sprite.angle = -15;
            await bump();
            sprite.position.set(x, y);
        } catch {} finally {
            sprite.angle = 0;
            if(sprite.animControl?.signal === signal) sprite.animControl = null;
        }
    }
    function drawGrid(turtle, width = GRID_LINEWIDTH) {
        turtle.clear();
        for (let i = 0; i < GRID_HEIGHT; i++) {
            turtle.moveTo(0,TILE_SIZE*i).lineTo(TILE_SIZE*GRID_WIDTH, TILE_SIZE*i).stroke({width: width});
        }
        for (let i = 0; i < GRID_WIDTH; i++) {
            turtle.moveTo(TILE_SIZE*i,0).lineTo(TILE_SIZE*i, TILE_SIZE*GRID_HEIGHT).stroke({width: width});
        }
        turtle.rect(0,0,TILE_SIZE*GRID_WIDTH,TILE_SIZE*GRID_HEIGHT).stroke({width: width})
        
        let arrowFrom = urlParams.get('arrowFrom');
        let arrowTo = urlParams.get('arrowTo');
        if (arrowFrom && arrowTo) {
            turtle.zIndex = 100;
            let arrowThickness = 7;
            let fromX = Number(arrowFrom.split(",")[0])
            let fromY = Number(arrowFrom.split(",")[1])
            let toX = Number(arrowTo.split(",")[0])
            let toY = Number(arrowTo.split(",")[1])
            let fromPos = tileToPos({x: fromX, y: fromY})
            let toPos = tileToPos({x: toX, y: toY});
            turtle.moveTo(fromPos.x, fromPos.y)
                .lineTo(toPos.x, toPos.y)
                .stroke({ color: 0xff0000, width: arrowThickness })
            const arrowSize = 45; // length of arrow head lines
            const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);

            // Two points for arrow head
            const leftAngle = angle + Math.PI / 6; // 30Â° spread
            const rightAngle = angle - Math.PI / 6;

            const leftX = toPos.x - Math.cos(leftAngle) * arrowSize;
            const leftY = toPos.y - Math.sin(leftAngle) * arrowSize;

            const rightX = toPos.x - Math.cos(rightAngle) * arrowSize;
            const rightY = toPos.y - Math.sin(rightAngle) * arrowSize;

            turtle.moveTo(toPos.x, toPos.y)
                .lineTo(leftX, leftY)
                .moveTo(toPos.x, toPos.y)
                .lineTo(rightX, rightY)
                .stroke({ color: 0xff0000, width: arrowThickness })
            
            window.lettuce.viewport.moveCenter((fromPos.x + toPos.x) / 2, (fromPos.y + toPos.y) / 2);
            window.lettuce.viewport.setZoom(0.5, true);
            //turtle.zIndex = -1;
        }
    }
    
    function resetTooltip(tooltip = window.lettuce.tooltip) {
        tooltip.locked = false;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.querySelector("#actions").innerHTML = "";
    }
    function mkTooltip(tile, pawn, pos, tooltip = window.lettuce.tooltip) {
        tooltip.element.querySelector("#tilecoords").innerText = `(${tile.x},${tile.y})`;
        tooltip.element.querySelector("#hoveredpawn").innerText = pawn ? pawn.displayName : "Nobody";
        tooltip.element.querySelector(".pfp").src = pawn ? (pawn?.avatarUri ? pawn.avatarUri : "/assets/p3b.png") : "";
        if(pawn?.killedAt) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = deathStamp(pawn);
            tooltip.element.querySelector("#killer").innerText = `Killed by ${window.lettuce.pawns.find(p=>p.id===pawn.killedById).displayName}`;
        } else if(pawn) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = unitStamp(pawn);
            tooltip.element.querySelector("#killer").innerText = "";
        } else {
            tooltip.element.querySelector("#hoveredunits").innerHTML = "";
            tooltip.element.querySelector("#killer").innerText = "";
        }
        tooltip.position.set(pos.x+20,pos.y);
    }
    function mkAction(icon, text, onclick = () => {}) {
        const action = document.createElement("button");
        action.innerHTML = `<i class="fa-solid fa-${icon}"></i> ${text}`;
        action.onclick = () => {
            onclick();
            resetTooltip();
        };
        return action;
    }
    function mkEvent(event) {
        const eventTime = new Date(event.timestamp);
        const wrapper = document.querySelector(`#eventspanel details[date="${eventTime.toLocaleDateString()}"]`) ?? mkEventWrap(eventTime);

        const actionByTint = getPawnTintCss(event.actionById);
        const actionToTint = getPawnTintCss(event.actionToId);
        
        const eventBlock = document.createElement("div");
        eventBlock.classList.add("event");
        eventBlock.innerHTML = `<div class="tint-image-holder"><img class="left" src="/assets/pawn_gs.png" alt=""/><img src="/assets/pawn_b.png" style="${actionByTint.filter}" class="tint left" alt=""></div><span></span><div class="tint-image-holder"><img class="right" src="/assets/pawn_gs.png"/><img src="/assets/pawn_b.png" style="${actionToTint.filter}" class="tint right" alt=""></div>`;
        if (event.actionType === 3) {
            eventBlock.innerHTML = `<div class="tint-image-holder"><img class="left" src="/assets/lettuce.png" alt=""/></div><span></span><div class="tint-image-holder"><img class="right" src="/assets/lettuce.png"/></div>`;
            
        }
        eventBlock.querySelector("span").innerText = event.eventText + ` at ${new Date(event.timestamp).toLocaleTimeString()}`;
        
        if(event.actionType === 0) {
            eventBlock.querySelectorAll("img").forEach(i=>i.remove())
            eventBlock.classList.add("slim");
        }
        
        wrapper.prepend(eventBlock);
    }
    
    function getPawnTintCss(pawnId) {
        const pawn = window.lettuce.pawns.find(p => p.id === pawnId);
        const color = new Color(pawn.color.r, pawn.color.g, pawn.color.b);
        const solver = new Solver(color);
        return solver.solve();
    }
    
    function mkEventWrap(time) {
        const eventWrap = document.createElement("details");
        eventWrap.open = true;
        eventWrap.setAttribute("date", time.toLocaleDateString());
        eventWrap.innerHTML = `<summary><span>${time.toLocaleDateString()}</span> <span>Day ${dayDiff(FIRST_EVENT_TIME, time) + 1}</span></summary>`;
        eventspanel.prepend(eventWrap);
        return eventWrap;
    }
    
    function updatePawn(id, data) {
        const pawn = window.lettuce.pawns.find(pawn=>pawn.id===id);
        if(!pawn) return;
        
        Object.assign(pawn, data);
        console.log(pawn.displayName, pawn.voted)
        document.querySelector(`#playerspanel [player="${id}"]`).querySelector(".units").innerHTML = pawn.alive ? unitStamp(pawn) : deathStamp(pawn);
        document.querySelector(`#playerspanel [player="${id}"]`).querySelector(".pfp .voteicon").classList.toggle("hidden", !pawn.voted);
        if(id === MY_UUID) document.querySelector(`#stats .units`).innerHTML = pawn.alive ? unitStamp(pawn) : deathStamp(pawn);
        
        // TODO: change pawn sprite too
    }
    
    // "im doing [something] in such a sketchy way", emilia tells me, while i'm writing my own sketchy code. sketchiness forever!!
    function panelSwap(panel) {
        const wantedPanel = document.querySelector(`#panels #${panel}panel`);
        if(!wantedPanel.classList.contains('hidden')) {
            wantedPanel.classList.add("hidden");
            game.removeAttribute("active-panel");
        } else {
            const currentPanel = document.querySelector(`#panels #${game.getAttribute("active-panel")}panel`);
            if(currentPanel) currentPanel.classList.add("hidden");
            wantedPanel.classList.remove("hidden");
            
            game.setAttribute("active-panel", panel)
        }
        window.lettuce.resizeViewport();
    }
    
    function mkCircle(turtle) {
        turtle.circle(0, 0, TILE_SIZE*4).stroke({ width: RANGE_LINEWIDTH, color: 0xff0000 });
        turtle.circle(0, 0, TILE_SIZE*7).stroke({ width: RANGE_LINEWIDTH, color: 0x00ff00 });
    }
</script>
