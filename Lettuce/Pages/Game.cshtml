@page
@using System.Security.Claims
@using OpenIddict.Abstractions
@model Lettuce.Pages.GameModel

@{
    ViewData["Title"] = "Lettuce Fighters";
}

<link rel="stylesheet" href="~/css/game.css" asp-append-version="true"/>
<script src="~/js/signalr/dist/browser/signalr.js" asp-append-version="true"></script>

<div id="pixi"></div>


<div id="stats">
    <div class="aviebox">
        <img class="pfp" src="@Model.OwnPawn?.AvatarUri" alt="" referrerpolicy="no-referrer">
        <div class="info">
            <span class="name">@Model.OwnPawn?.DisplayName</span>
            <div class="units">
                <span class="health">
                    <i style="" class="fa-solid fa-heart@(Model.OwnPawn?.Health < 1 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn?.Health < 2 ? "-crack" : "")"></i>
                    <i class="fa-solid fa-heart@(Model.OwnPawn?.Health < 3 ? "-crack" : "")"></i>
                 </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">@Model.OwnPawn?.Actions</span>
                </span>
            </div>
        </div>
    </div>
    <div class="metas">
        <div class="tabs">
            <button><img src="/assets/pawn.png"> players</button>
            <button><img src="/assets/pawn_dead.png"> events</button>
            <button><i class="fa-solid fa-crosshairs" style="color: red"></i> ranges</button>
        </div>
        <span id="pcount">? fighter online</span>
    </div>
</div>

<div style="display:none" id="connection-indicator" class="connection-indicator">
    <i style="display:none" id="connection-indicator-connected" class="fa-regular fa-wifi"></i>
    <i style="display:none" id="connection-indicator-disconnected" class="fa-regular fa-wifi-slash"></i>
    <i style="display:none" id="connection-indicator-connecting" class="fa-regular fa-wifi-slash"></i>
</div>

<script>
    const MY_UUID = "@Model.OwnPawn?.Id.ToString()";
    const GRID_WIDTH = @Program.GridWidth;
    const GRID_HEIGHT = @Program.GridHeight;
    const PAWN_SIZE = 100;
    const TILE_PADDING = 10;
    const TILE_SIZE = PAWN_SIZE+TILE_PADDING;
    const GRID_LINEWIDTH = 2;
    const sleep = ms => new Promise(r => setTimeout(r, ms));
</script>
<script src="/js/pixi/pixi.min.js" asp-append-version="true"></script>
<script src="/js/pixi/pixi_viewport.iife.js" asp-append-version="true"></script>

<script>
    window.lettuce = {};
    window.lettuce.isConnected = false;
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("disableUi")) {
        document.getElementById("stats").remove();
        document.getElementById("connection-indicator").remove();
        document.querySelector("header").remove();
        document.getElementById("pixi").style.height = "100vh";
    }
    let statusTimeout;
    let connection = new signalR.HubConnectionBuilder()
        .withUrl("/lettuceHub")
        .withAutomaticReconnect()
        .build();

    showConnectionStatus("connecting")
    connection.start().then(async function () {
        onConnect(false)
        window.lettuce.pawns = await connection.invoke("GetPawns");
        console.log(window.lettuce.pawns);
        
        setInterval(async () => {
            if (!window.lettuce.isConnected) return;
            let count = await connection.invoke("GetLiveCount")
            updateLiveCount(count)
        }, 1000)


        window.lettuce.pawnTexture = await PIXI.Assets.load("/assets/pawn.png");
        window.lettuce.deadPawnTexture = await PIXI.Assets.load("/assets/pawn_dead.png");
        window.lettuce.pawnSprites = {};

        const app = new PIXI.Application();
        await app.init({background: "rgb(46,46,46)", resizeTo: document.getElementById("pixi")});

        const viewport = new pixi_viewport.Viewport({
            screenWidth: document.getElementById("pixi").clientWidth, screenHeight: document.getElementById("pixi").clientHeight,
            worldWidth: TILE_SIZE*GRID_WIDTH, worldHeight: TILE_SIZE*GRID_HEIGHT, events: app.renderer.events
        }); viewport.drag().pinch().wheel().decelerate().clampZoom({minScale:0.2, maxScale:3})
        window.lettuce.viewport = viewport;
        window.addEventListener("resize", () => {
            viewport.resize(document.getElementById("pixi").clientWidth, document.getElementById("pixi").clientHeight); 
        })

        const turtle = new PIXI.Graphics();
        const tooltip = new PIXI.DOMContainer();
        window.lettuce.tooltip = tooltip;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.innerHTML = `<div id="tooltip"><div id="tileinfowrap"><div id="tiledata"><span id="tileinfo"><span id="tilecoords"></span>&bull;<span id="hoveredpawn">Nobody</span></span><span id="hoveredunits"></span></div><img class="pfp" src=""></div><span id="actions"></span></div>`
        
        if (urlParams.get("disableUi")) {
            tooltip.element.style.display = "none";
        }
        
        turtle.zIndex = -1;

        drawGrid(turtle);
        viewport.on("zoomed", () => {
            drawGrid(turtle, GRID_LINEWIDTH/viewport.scale.x)
            tooltip.scale = 1/viewport.scale.x;
        })

        let dragging = false;
        viewport.on('pointermove', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            
            if(tooltip.locked) return;
            mkTooltip(tile,pawn,pos);
        });
        viewport.on('pointerup', (event) => {
            const pos = viewport.toWorld(event.global);
            const tile = posToTile(pos);
            const pawn = window.lettuce.pawns.find(pawn => pawn.x === tile.x && pawn.y === tile.y);
            const myPawn = window.lettuce.pawns.find(pawn => pawn.id === MY_UUID);
            
            if(dragging) return;
            
            tooltip.locked = true;
            mkTooltip(tile,pawn,pos);
            tooltip.element.classList.remove("pointerphobe");
            tooltip.element.querySelector("#actions").innerHTML = "";
            
            if(myPawn && pawn !== myPawn) {
                const distance = tileDistance(tile);
                if(!pawn) {
                    if(distance <= 1.5) tooltip.element.querySelector("#actions").appendChild(mkAction("person-walking", "Move here", () => connection.invoke("MoveTo", tile.x, tile.y)))
                } else if(pawn.alive) {
                    if(distance <= 4.25) tooltip.element.querySelector("#actions").appendChild(mkAction("face-angry", "Attack", () => attack(pawn.id)))
                    if(distance <= 7.5) tooltip.element.querySelector("#actions").appendChild(mkAction("hand-holding-heart", "Gift lettuce", () => gift(pawn.id)))
                }
            } else if(myPawn) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("volume", "It's me!", () => {
                    let audio = new Audio("/sfx/itsme.wav");
                    audio.volume = 0.1;
                    audio.play();
                }));
                tooltip.element.querySelector("#actions").appendChild(mkAction("messages", "Chat...", () => connection.invoke("Speak", prompt("What're you gonna say?"))));
            } else if(@(Model.IsPlayer ? "false" : "true")) {
                tooltip.element.querySelector("#actions").appendChild(mkAction("right-to-bracket", "Log in", () => location.pathname = "/login"));
            }
            
            tooltip.element.querySelector("#actions").appendChild(mkAction("ban", "Cancel"));
        });
        viewport.on('drag-start', () => {
            resetTooltip(tooltip);
            dragging = true;
        })
        viewport.on('drag-end', () => setTimeout(() => dragging = false, 0))

        viewport.addChild(tooltip);
        viewport.addChild(turtle);
        app.stage.addChild(viewport);
        document.getElementById("pixi").appendChild(app.canvas);


        window.lettuce.pawns.forEach(pawn => {
            const sprite = viewport.addChild(new PIXI.Sprite(pawn.alive ? window.lettuce.pawnTexture : window.lettuce.deadPawnTexture));
            sprite.anchor.set(0.5);
            sprite.zIndex = 99;
            let color = pawn.color.name;
            sprite.tint = "0x" + color;
            sprite.width = sprite.height = PAWN_SIZE;
            sprite.eventMode = "static";
            sprite.pawnID = pawn.id;
            moveToTile(sprite, pawn.x, pawn.y, false)
            window.lettuce.pawnSprites[pawn.id] = sprite;
        })
        window.lettuce.initialLoadDone = true;
        app.ticker.add(() => {})
    }).catch(function (err) {
        return console.error(err.toString());
    });
    
    function showConnectionStatus(status) {
        try {
            if (statusTimeout) clearTimeout(statusTimeout)
            switch (status) {
                case "disconnected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "unset";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connected":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "unset";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
                    break;
                case "connecting":
                    document.getElementById("connection-indicator").style.display = "unset";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "unset";
                    break;
                default:
                    document.getElementById("connection-indicator").style.display = "none";
                    document.getElementById("connection-indicator-connected").style.display = "none";
                    document.getElementById("connection-indicator-disconnected").style.display = "none";
                    document.getElementById("connection-indicator-connecting").style.display = "none";
            }
        } catch (e) {
            console.error(e);
        }
    }
    
    connection.onreconnected(() => {
        onConnect(true);
    });

    connection.onclose(() => {
        showConnectionStatus("disconnected");
    })

    connection.onreconnecting(error => {
        onDisconnect(error);
        showConnectionStatus("connecting");
    });

    function onDisconnect(error) {
        console.warn("Connection lost due to error:", error);
        window.lettuce.isConnected = false;
    }

    function onConnect(isReconnect) {
        console.log(`${isReconnect ? "Rec" : "C"}onnected!`);
        window.lettuce.isConnected = true;
        showConnectionStatus("connected");
        statusTimeout = setTimeout(() => {
            showConnectionStatus();
        }, 2000);
    }


    connection.on("UpdateLiveCount", (count) => {
        console.log("Got count from server");
        updateLiveCount(count);
    })
    
    connection.on("MoveTo", (pawnId, x, y, actions) => {
        console.log(pawnId, x, y);
        let pawn = window.lettuce.pawns.find(p => p.id === pawnId);
        pawn.x = x;
        pawn.y = y;
        pawn.actions = actions;
        moveToTile(window.lettuce.pawnSprites[pawn.id], x, y);
    })

    connection.on("Attack", (attackerId, attackedId) => {
        // TODO: Leafy Green this
        console.log(attackerId, attackedId);
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        attacker.actions -= 1;
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        attacked.health -= 1;
        if (attacked.health < 1) {
            attacked.alive = false;
            const atkSprite = window.lettuce.pawnSprites[attacked.id];
            if(atkSprite) atkSprite.texture = window.lettuce.deadPawnTexture;
        }
    })

    connection.on("Gift", (attackerId, attackedId, amount) => {
        // TODO: Leafy Green this
        console.log(attackerId, attackedId, amount);
        let attacker = window.lettuce.pawns.find(p => p.id === attackerId);
        attacker.actions -= amount;
        let attacked = window.lettuce.pawns.find(p => p.id === attackedId);
        attacked.actions += amount;
    })
    
    connection.on("LettuceDrop", (amount) => {
        console.log("Drop", amount);
        window.lettuce.pawns.forEach(pawn => {
            if (pawn.id === "ffffffff-ffff-ffff-ffff-ffffffffffff") return;
            pawn.actions += amount;
        })
    })
    
    function updateLiveCount(count) {
        document.getElementById("pcount").innerHTML = `${count} fighter${count !== 1 ? "s" : ""} online`;
    }
    
    async function attack(id) {
        await connection.invoke("Attack", id);
    }

    async function gift(id) {
        await connection.invoke("Gift", id);
    }
    
    // Leafy Green

    const posToTile = (pos) => ({x:Math.floor(pos.x/TILE_SIZE),y:Math.floor(pos.y/TILE_SIZE)});
    const tileToPos = (tile) => ({x: tile.x * TILE_SIZE + TILE_SIZE / 2,y: tile.y * TILE_SIZE + TILE_SIZE / 2});
    const isDiffTile = (tile1,tile2) => tile1.x !== tile2.x || tile1.y !== tile2.y;
    const tileDistance = (tile1, tile2=window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        // from lettuce1
        let diffX = tile1.x - tile2.x;
        let diffY = tile1.y - tile2.y;
        return Math.sqrt(diffX * diffX + diffY * diffY);
    }
    const deathStamp = (pawn) => {
        if(!pawn?.killedAt) return "";
        return `<i class="fa-solid fa-tombstone"></i> ${((Date.now() - new Date(pawn.killedAt).getTime()) / 1000 / 60 / 60).toFixed(2)} hours`; //from lettuce1
    }
    const unitStamp = (pawn = window.lettuce.pawns.find(pawn=>pawn.id===MY_UUID)) => {
        if(!pawn) return "";
        return `<span class="health">
                    <i class="fa-solid fa-heart${pawn.health<1?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<2?"-crack":""}"></i>
                    <i class="fa-solid fa-heart${pawn.health<3?"-crack":""}"></i>
                 </span>
                <span class="lettuce">
                    <img src="/assets/lettuce.png" alt=""> <span class="lettucecount">${pawn.actions}</span>
                </span>`
    }
    
    const moveToTile = async (sprite, tx, ty, animate = true) => {
        const sx = tx * TILE_SIZE + TILE_SIZE / 2; const sy = ty * TILE_SIZE + TILE_SIZE / 2;
        return animate ? move(sprite, tx * TILE_SIZE + TILE_SIZE / 2, ty * TILE_SIZE + TILE_SIZE / 2) : sprite.position.set(sx,sy);
    }
    async function move(sprite, x, y) {
        if(sprite.animControl) {
            sprite.animControl.abort();
            sprite.animControl = null;
        }

        sprite.animControl = new AbortController();
        const {signal} = sprite.animControl;
        const xDiff = (x-sprite.position.x)/3;
        const yDiff = (y-sprite.position.y)/3;
        const bump = async () => {await sleep(225);if(signal.aborted)throw"stop";sprite.position.set(sprite.position.x+xDiff, sprite.position.y+yDiff);}

        try {
            await bump();
            sprite.angle = 15;
            await bump();
            sprite.angle = -15;
            await bump();
            sprite.position.set(x, y);
        } catch {} finally {
            sprite.angle = 0;
            if(sprite.animControl?.signal === signal) sprite.animControl = null;
        }
    }
    function drawGrid(turtle, width = GRID_LINEWIDTH) {
        turtle.clear();
        for (let i = 0; i < GRID_HEIGHT; i++) {
            turtle.moveTo(0,TILE_SIZE*i).lineTo(TILE_SIZE*GRID_WIDTH, TILE_SIZE*i).stroke({width: width});
        }
        for (let i = 0; i < GRID_WIDTH; i++) {
            turtle.moveTo(TILE_SIZE*i,0).lineTo(TILE_SIZE*i, TILE_SIZE*GRID_HEIGHT).stroke({width: width});
        }
        turtle.rect(0,0,TILE_SIZE*GRID_WIDTH,TILE_SIZE*GRID_HEIGHT).stroke({width: width})
        
        let arrowFrom = urlParams.get('arrowFrom');
        let arrowTo = urlParams.get('arrowTo');
        if (arrowFrom && arrowTo) {
            turtle.zIndex = 100;
            let arrowThickness = 7;
            let fromX = Number(arrowFrom.split(",")[0])
            let fromY = Number(arrowFrom.split(",")[1])
            let toX = Number(arrowTo.split(",")[0])
            let toY = Number(arrowTo.split(",")[1])
            let fromPos = tileToPos({x: fromX, y: fromY})
            let toPos = tileToPos({x: toX, y: toY});
            turtle.moveTo(fromPos.x, fromPos.y)
                .lineTo(toPos.x, toPos.y)
                .stroke({ color: 0xff0000, width: arrowThickness })
            const arrowSize = 45; // length of arrow head lines
            const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);

            // Two points for arrow head
            const leftAngle = angle + Math.PI / 6; // 30° spread
            const rightAngle = angle - Math.PI / 6;

            const leftX = toPos.x - Math.cos(leftAngle) * arrowSize;
            const leftY = toPos.y - Math.sin(leftAngle) * arrowSize;

            const rightX = toPos.x - Math.cos(rightAngle) * arrowSize;
            const rightY = toPos.y - Math.sin(rightAngle) * arrowSize;

            turtle.moveTo(toPos.x, toPos.y)
                .lineTo(leftX, leftY)
                .moveTo(toPos.x, toPos.y)
                .lineTo(rightX, rightY)
                .stroke({ color: 0xff0000, width: arrowThickness })
            
            window.lettuce.viewport.moveCenter((fromPos.x + toPos.x) / 2, (fromPos.y + toPos.y) / 2);
            window.lettuce.viewport.setZoom(0.5, true);
            //turtle.zIndex = -1;
        }
    }
    
    function resetTooltip(tooltip = window.lettuce.tooltip) {
        tooltip.locked = false;
        tooltip.element.classList.add("pointerphobe");
        tooltip.element.querySelector("#hoveredpawn").innerText = "Nobody";
        tooltip.element.querySelector("#actions").innerHTML = "";
    }
    function mkTooltip(tile, pawn, pos, tooltip = window.lettuce.tooltip) {
        tooltip.element.querySelector("#tilecoords").innerText = `(${tile.x},${tile.y})`;
        tooltip.element.querySelector("#hoveredpawn").innerText = pawn ? pawn.displayName : "Nobody";
        tooltip.element.querySelector(".pfp").src = pawn?.avatarUri ? pawn.avatarUri : "";
        if(pawn?.killedAt) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = deathStamp(pawn);
        } else if(pawn) {
            tooltip.element.querySelector("#hoveredunits").innerHTML = unitStamp(pawn);
        } else {
            tooltip.element.querySelector("#hoveredunits").innerHTML = "";
        }
        tooltip.position.set(pos.x+20,pos.y);
    }
    function mkAction(icon, text, onclick = () => {}) {
        const action = document.createElement("button");
        action.innerHTML = `<i class="fa-solid fa-${icon}"></i> ${text}`;
        action.onclick = () => {
            onclick();
            resetTooltip();
        };
        return action;
    }
    
</script>
